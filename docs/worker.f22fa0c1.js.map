{"mappings":"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","sources":["./node_modules/comlink/dist/esm/comlink.mjs","./website/worker.js"],"sourcesContent":["/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","///////////////////////////////////////////////////////////////////////\n// JSONCrush by Frank Force [MIT] https://github.com/KilledByAPixel/JSONCrush\n///////////////////////////////////////////////////////////////////////\n\nimport * as Comlink from 'comlink';\n\nexport function crush(string) {\n    // string = encodeURIComponent(string);\n\n    const maxSubstringLength = 50; // speed it up by limiting max length\n    const delimiter = '\\u0001'; // used to split parts of crushed string\n\n    const JSCrush = (string, replaceCharacters) => {\n        // JSCrush Algorithm (repleace repeated substrings with single characters)\n        let replaceCharacterPos = replaceCharacters.length;\n        let splitString = '';\n\n        const ByteLength = string => encodeURI(encodeURIComponent(string)).replace(/%../g, 'i').length;\n        const HasUnmatchedSurrogate = string => {\n            // check ends of string for unmatched surrogate pairs\n            let c1 = string.charCodeAt(0);\n            let c2 = string.charCodeAt(string.length - 1);\n            return (c1 >= 0xdc00 && c1 <= 0xdfff) || (c2 >= 0xd800 && c2 <= 0xdbff);\n        };\n\n        // count instances of substrings\n        let substringCount = {};\n        for (let substringLength = 2; substringLength < maxSubstringLength; substringLength++)\n            for (let i = 0; i < string.length - substringLength; ++i) {\n                let substring = string.substr(i, substringLength);\n\n                // don't recount if already in list\n                if (substringCount[substring]) continue;\n\n                // prevent breaking up unmatched surrogates\n                if (HasUnmatchedSurrogate(substring)) continue;\n\n                // count how many times the substring appears\n                let count = 1;\n                for (let substringPos = string.indexOf(substring, i + substringLength); substringPos >= 0; ++count)\n                    substringPos = string.indexOf(substring, substringPos + substringLength);\n\n                // add to list if it appears multiple times\n                if (count > 1) substringCount[substring] = count;\n            }\n\n        while (true) {\n            // loop while string can be crushed more\n            // get the next character that is not in the string\n            for (; replaceCharacterPos-- && string.includes(replaceCharacters[replaceCharacterPos]); ) {}\n            if (replaceCharacterPos < 0) break; // ran out of replacement characters\n            let replaceCharacter = replaceCharacters[replaceCharacterPos];\n\n            // find the longest substring to replace\n            let bestSubstring;\n            let bestLengthDelta = 0;\n            let replaceByteLength = ByteLength(replaceCharacter);\n            for (let substring in substringCount) {\n                // calculate change in length of string if it substring was replaced\n                let count = substringCount[substring];\n                let lengthDelta = (count - 1) * ByteLength(substring) - (count + 1) * replaceByteLength;\n                if (!splitString.length) lengthDelta -= ByteLength(delimiter); // include the delimeter length\n                if (lengthDelta <= 0) delete substringCount[substring];\n                else if (lengthDelta > bestLengthDelta) {\n                    bestSubstring = substring;\n                    bestLengthDelta = lengthDelta;\n                }\n            }\n            if (!bestSubstring) break; // string can't be compressed further\n\n            // create new string with the split character\n            string = string.split(bestSubstring).join(replaceCharacter) + replaceCharacter + bestSubstring;\n            splitString = replaceCharacter + splitString;\n\n            // update substring count list after the replacement\n            let newSubstringCount = {};\n            for (let substring in substringCount) {\n                // make a new substring with the replacement\n                let newSubstring = substring.split(bestSubstring).join(replaceCharacter);\n\n                // count how many times the new substring appears\n                let count = 0;\n                for (let i = string.indexOf(newSubstring); i >= 0; ++count)\n                    i = string.indexOf(newSubstring, i + newSubstring.length);\n\n                // add to list if it appears multiple times\n                if (count > 1) newSubstringCount[newSubstring] = count;\n            }\n            substringCount = newSubstringCount;\n        }\n\n        return { a: string, b: splitString };\n    };\n\n    // create a string of replacement characters\n    let characters = [];\n\n    // prefer replacing with characters that will not be escaped by encodeURIComponent\n    const unescapedCharacters = `-_.!~*'()`;\n    for (let i = 127; --i; ) {\n        if (\n            (i >= 48 && i <= 57) || // 0-9\n            (i >= 65 && i <= 90) || // A-Z\n            (i >= 97 && i <= 122) || // a-z\n            unescapedCharacters.includes(String.fromCharCode(i))\n        )\n            characters.push(String.fromCharCode(i));\n    }\n\n    // pick from extended set last\n    for (let i = 32; i < 255; ++i) {\n        let c = String.fromCharCode(i);\n        if (c != '\\\\' && !characters.includes(c)) characters.unshift(c);\n    }\n\n    // remove delimiter if it is found in the string\n    string = string.replace(new RegExp(delimiter, 'g'), '');\n\n    // swap out common json characters\n    string = swap(string);\n\n    // crush with JS crush\n    const crushed = JSCrush(string, characters);\n\n    // insert delimiter between JSCrush parts\n    let crushedString = crushed.a;\n    if (crushed.b.length) crushedString += delimiter + crushed.b;\n\n    // encode URI\n    return encodeURIComponent(crushedString);\n}\n\nexport function uncrush(string) {\n    // string must be a decoded URI component, searchParams.get() does this automatically\n    string = decodeURIComponent(string);\n\n    // unsplit the string using the delimiter\n    const stringParts = string.split('\\u0001');\n\n    // JSUncrush algorithm\n    let uncrushedString = stringParts[0];\n    if (stringParts.length > 1) {\n        let splitString = stringParts[1];\n        for (let character of splitString) {\n            // split the string using the current splitCharacter\n            let splitArray = uncrushedString.split(character);\n\n            // rejoin the string with the last element from the split\n            uncrushedString = splitArray.join(splitArray.pop());\n        }\n    }\n\n    // unswap the json characters in reverse direction\n    return swap(uncrushedString, 0);\n}\n\nfunction swap(string, forward = 1) {\n    // swap out characters for lesser used ones that wont get escaped\n    const swapGroups = [\n        ['\"', \"'\"],\n        [\"':\", '!'],\n        [\",'\", '~'],\n        ['}', ')', '\\\\', '\\\\'],\n        ['{', '(', '\\\\', '\\\\']\n    ];\n\n    const Swap = (string, g) => {\n        let regex = new RegExp(`${(g[2] ? g[2] : '') + g[0]}|${(g[3] ? g[3] : '') + g[1]}`, 'g');\n        return string.replace(regex, $1 => ($1 === g[0] ? g[1] : g[0]));\n    };\n\n    // need to be able to swap characters in reverse direction for uncrush\n    if (forward) for (let i = 0; i < swapGroups.length; ++i) string = Swap(string, swapGroups[i]);\n    else for (let i = swapGroups.length; i--; ) string = Swap(string, swapGroups[i]);\n\n    return string;\n}\n\nfunction parse(jsonString) {\n    return JSON.parse(jsonString);\n}\n\nComlink.expose({\n    crush,\n    uncrush,\n    parse\n});\n"],"names":["proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","value","serialized","Error","isError","message","name","stack","Object","assign","ep","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","[object Object]","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","get","_target","requestResponseMessage","p","toString","length","r","bind","_thisArg","rawArgumentList","last","processArguments","construct","processed","v","arr","Array","prototype","concat","WeakMap","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","swap","string","forward","swapGroups","Swap","g","regex","RegExp","replace","$1","i","$cb5b82b749316de4a6f0306f0273b$export$expose","crush","characters","unescapedCharacters","includes","String","fromCharCode","push","c","unshift","crushed","replaceCharacters","replaceCharacterPos","splitString","ByteLength","encodeURI","encodeURIComponent","HasUnmatchedSurrogate","c1","charCodeAt","c2","substringCount","substringLength","substring","substr","count","substringPos","indexOf","bestSubstring","replaceCharacter","bestLengthDelta","replaceByteLength","lengthDelta","split","newSubstringCount","newSubstring","a","b","JSCrush","crushedString","uncrush","stringParts","decodeURIComponent","uncrushedString","character","splitArray","pop","parse","jsonString","JSON"],"version":3,"file":"worker.f22fa0c1.js.map"}