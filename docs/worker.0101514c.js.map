{"version":3,"sources":["../../src/comlink.ts","worker.js"],"names":["crush","string","characters","unescapedCharacters","i","includes","String","fromCharCode","push","c","unshift","crushed","replaceCharacters","replaceCharacterPos","length","splitString","ByteLength","encodeURI","encodeURIComponent","replace","HasUnmatchedSurrogate","c1","charCodeAt","c2","substringCount","substringLength","substring","substr","count","substringPos","indexOf","replaceCharacter","bestSubstring","bestLengthDelta","replaceByteLength","lengthDelta","split","join","newSubstringCount","newSubstring","a","b","JSCrush","swap","RegExp","crushedString","uncrush","stringParts","decodeURIComponent","uncrushedString","character","splitArray","pop","forward","swapGroups","Swap","g","regex","$1","parse","jsonString","JSON","Comlink","expose"],"mappings":"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","file":"worker.0101514c.js","sourceRoot":"../website","sourcesContent":["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst throwSet = new WeakSet();\n\n// prettier-ignore\ntype Promisify<T> =\n  T extends { [proxyMarker]: boolean }\n    ? Promise<Remote<T>>\n    : T extends (...args: infer R1) => infer R2\n        ? (...args: R1) => Promisify<R2>\n        : Promise<T>;\n\n// prettier-ignore\nexport type Remote<T> =\n  (\n    T extends (...args: infer R1) => infer R2\n      ? (...args: R1) => Promisify<R2>\n      : unknown\n  ) &\n  (\n    T extends { new (...args: infer R1): infer R2 }\n      ? { new (...args: R1): Promise<Remote<R2>> }\n      : unknown\n  ) &\n  (\n    T extends Object\n      ? { [K in keyof T]: Remote<T[K]> }\n      : unknown\n  ) &\n  (\n    T extends string\n      ? Promise<string>\n      : unknown\n  ) &\n  (\n    T extends number\n      ? Promise<number>\n      : unknown\n  ) &\n  (\n    T extends boolean\n      ? Promise<boolean>\n      : unknown\n  ) & {\n    [createEndpoint]: MessagePort;\n    [releaseProxy]: () => void;\n  };\n\ndeclare var x: Remote<number>;\n\ndeclare var y: PromiseLike<number>;\n\nexport interface TransferHandler {\n  canHandle(obj: any): boolean;\n  serialize(obj: any): [any, Transferable[]];\n  deserialize(obj: any): any;\n}\n\nexport const transferHandlers = new Map<string, TransferHandler>([\n  [\n    \"proxy\",\n    {\n      canHandle: obj => obj && obj[proxyMarker],\n      serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n      },\n      deserialize: (port: MessagePort) => {\n        port.start();\n        return wrap(port);\n      }\n    }\n  ],\n  [\n    \"throw\",\n    {\n      canHandle: obj => throwSet.has(obj),\n      serialize(obj) {\n        const isError = obj instanceof Error;\n        let serialized = obj;\n        if (isError) {\n          serialized = {\n            isError,\n            message: obj.message,\n            stack: obj.stack\n          };\n        }\n        return [serialized, []];\n      },\n      deserialize(obj) {\n        if ((obj as any).isError) {\n          throw Object.assign(new Error(), obj);\n        }\n        throw obj;\n      }\n    }\n  ]\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message)\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n      }\n    } catch (e) {\n      returnValue = e;\n      throwSet.add(e);\n    }\n    Promise.resolve(returnValue)\n      .catch(e => {\n        throwSet.add(e);\n        return e;\n      })\n      .then(returnValue => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function() {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map(p => p.toString())\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map(p => p.toString())\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map(p => p.toString()),\n          value\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map(p => p.toString()),\n          argumentList\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map(p => p.toString()),\n          argumentList\n        },\n        transferables\n      ).then(fromWireValue);\n    }\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer(obj: any, transfers: Transferable[]) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & { [proxyMarker]: true } {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue\n        },\n        transferables\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value\n    },\n    transferCache.get(value) || []\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise(resolve => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","///////////////////////////////////////////////////////////////////////\n// JSONCrush by Frank Force [MIT] https://github.com/KilledByAPixel/JSONCrush\n///////////////////////////////////////////////////////////////////////\n\nimport * as Comlink from 'comlink';\n\nexport function crush(string) {\n    // string = encodeURIComponent(string);\n\n    const maxSubstringLength = 50; // speed it up by limiting max length\n    const delimiter = '\\u0001'; // used to split parts of crushed string\n\n    const JSCrush = (string, replaceCharacters) => {\n        // JSCrush Algorithm (repleace repeated substrings with single characters)\n        let replaceCharacterPos = replaceCharacters.length;\n        let splitString = '';\n\n        const ByteLength = string => encodeURI(encodeURIComponent(string)).replace(/%../g, 'i').length;\n        const HasUnmatchedSurrogate = string => {\n            // check ends of string for unmatched surrogate pairs\n            let c1 = string.charCodeAt(0);\n            let c2 = string.charCodeAt(string.length - 1);\n            return (c1 >= 0xdc00 && c1 <= 0xdfff) || (c2 >= 0xd800 && c2 <= 0xdbff);\n        };\n\n        // count instances of substrings\n        let substringCount = {};\n        for (let substringLength = 2; substringLength < maxSubstringLength; substringLength++)\n            for (let i = 0; i < string.length - substringLength; ++i) {\n                let substring = string.substr(i, substringLength);\n\n                // don't recount if already in list\n                if (substringCount[substring]) continue;\n\n                // prevent breaking up unmatched surrogates\n                if (HasUnmatchedSurrogate(substring)) continue;\n\n                // count how many times the substring appears\n                let count = 1;\n                for (let substringPos = string.indexOf(substring, i + substringLength); substringPos >= 0; ++count)\n                    substringPos = string.indexOf(substring, substringPos + substringLength);\n\n                // add to list if it appears multiple times\n                if (count > 1) substringCount[substring] = count;\n            }\n\n        while (true) {\n            // loop while string can be crushed more\n            // get the next character that is not in the string\n            for (; replaceCharacterPos-- && string.includes(replaceCharacters[replaceCharacterPos]); ) {}\n            if (replaceCharacterPos < 0) break; // ran out of replacement characters\n            let replaceCharacter = replaceCharacters[replaceCharacterPos];\n\n            // find the longest substring to replace\n            let bestSubstring;\n            let bestLengthDelta = 0;\n            let replaceByteLength = ByteLength(replaceCharacter);\n            for (let substring in substringCount) {\n                // calculate change in length of string if it substring was replaced\n                let count = substringCount[substring];\n                let lengthDelta = (count - 1) * ByteLength(substring) - (count + 1) * replaceByteLength;\n                if (!splitString.length) lengthDelta -= ByteLength(delimiter); // include the delimeter length\n                if (lengthDelta <= 0) delete substringCount[substring];\n                else if (lengthDelta > bestLengthDelta) {\n                    bestSubstring = substring;\n                    bestLengthDelta = lengthDelta;\n                }\n            }\n            if (!bestSubstring) break; // string can't be compressed further\n\n            // create new string with the split character\n            string = string.split(bestSubstring).join(replaceCharacter) + replaceCharacter + bestSubstring;\n            splitString = replaceCharacter + splitString;\n\n            // update substring count list after the replacement\n            let newSubstringCount = {};\n            for (let substring in substringCount) {\n                // make a new substring with the replacement\n                let newSubstring = substring.split(bestSubstring).join(replaceCharacter);\n\n                // count how many times the new substring appears\n                let count = 0;\n                for (let i = string.indexOf(newSubstring); i >= 0; ++count)\n                    i = string.indexOf(newSubstring, i + newSubstring.length);\n\n                // add to list if it appears multiple times\n                if (count > 1) newSubstringCount[newSubstring] = count;\n            }\n            substringCount = newSubstringCount;\n        }\n\n        return { a: string, b: splitString };\n    };\n\n    // create a string of replacement characters\n    let characters = [];\n\n    // prefer replacing with characters that will not be escaped by encodeURIComponent\n    const unescapedCharacters = `-_.!~*'()`;\n    for (let i = 127; --i; ) {\n        if (\n            (i >= 48 && i <= 57) || // 0-9\n            (i >= 65 && i <= 90) || // A-Z\n            (i >= 97 && i <= 122) || // a-z\n            unescapedCharacters.includes(String.fromCharCode(i))\n        )\n            characters.push(String.fromCharCode(i));\n    }\n\n    // pick from extended set last\n    for (let i = 32; i < 255; ++i) {\n        let c = String.fromCharCode(i);\n        if (c != '\\\\' && !characters.includes(c)) characters.unshift(c);\n    }\n\n    // remove delimiter if it is found in the string\n    string = string.replace(new RegExp(delimiter, 'g'), '');\n\n    // swap out common json characters\n    string = swap(string);\n\n    // crush with JS crush\n    const crushed = JSCrush(string, characters);\n\n    // insert delimiter between JSCrush parts\n    let crushedString = crushed.a;\n    if (crushed.b.length) crushedString += delimiter + crushed.b;\n\n    // encode URI\n    return encodeURIComponent(crushedString);\n}\n\nexport function uncrush(string) {\n    // string must be a decoded URI component, searchParams.get() does this automatically\n    string = decodeURIComponent(string);\n\n    // unsplit the string using the delimiter\n    const stringParts = string.split('\\u0001');\n\n    // JSUncrush algorithm\n    let uncrushedString = stringParts[0];\n    if (stringParts.length > 1) {\n        let splitString = stringParts[1];\n        for (let character of splitString) {\n            // split the string using the current splitCharacter\n            let splitArray = uncrushedString.split(character);\n\n            // rejoin the string with the last element from the split\n            uncrushedString = splitArray.join(splitArray.pop());\n        }\n    }\n\n    // unswap the json characters in reverse direction\n    return swap(uncrushedString, 0);\n}\n\nfunction swap(string, forward = 1) {\n    // swap out characters for lesser used ones that wont get escaped\n    const swapGroups = [\n        ['\"', \"'\"],\n        [\"':\", '!'],\n        [\",'\", '~'],\n        ['}', ')', '\\\\', '\\\\'],\n        ['{', '(', '\\\\', '\\\\']\n    ];\n\n    const Swap = (string, g) => {\n        let regex = new RegExp(`${(g[2] ? g[2] : '') + g[0]}|${(g[3] ? g[3] : '') + g[1]}`, 'g');\n        return string.replace(regex, $1 => ($1 === g[0] ? g[1] : g[0]));\n    };\n\n    // need to be able to swap characters in reverse direction for uncrush\n    if (forward) for (let i = 0; i < swapGroups.length; ++i) string = Swap(string, swapGroups[i]);\n    else for (let i = swapGroups.length; i--; ) string = Swap(string, swapGroups[i]);\n\n    return string;\n}\n\nfunction parse(jsonString) {\n    return JSON.parse(jsonString);\n}\n\nComlink.expose({\n    crush,\n    uncrush,\n    parse\n});\n"]}