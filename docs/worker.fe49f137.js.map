{"mappings":"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","sources":["./node_modules/comlink/dist/esm/comlink.mjs","./website/worker.js"],"sourcesContent":["/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: \"RELEASE\" /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: \"GET\" /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: \"SET\" /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: \"ENDPOINT\" /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"APPLY\" /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"CONSTRUCT\" /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","///////////////////////////////////////////////////////////////////////\n// JSONCrush by Frank Force [MIT] https://github.com/KilledByAPixel/JSONCrush\n///////////////////////////////////////////////////////////////////////\n\nimport * as Comlink from 'comlink';\n\nconst JSONCrush = (string, maxSubstringLength = 50) => {\n    const delimiter = '\\u0001'; // used to split parts of crushed string\n\n    const JSCrush = (string, replaceCharacters) => {\n        // JSCrush Algorithm (repleace repeated substrings with single characters)\n        let replaceCharacterPos = replaceCharacters.length;\n        let splitString = '';\n\n        const ByteLength = (string) => encodeURI(encodeURIComponent(string)).replace(/%../g, 'i').length;\n        const HasUnmatchedSurrogate = (string) => {\n            // check ends of string for unmatched surrogate pairs\n            let c1 = string.charCodeAt(0);\n            let c2 = string.charCodeAt(string.length - 1);\n            return (c1 >= 0xdc00 && c1 <= 0xdfff) || (c2 >= 0xd800 && c2 <= 0xdbff);\n        };\n\n        // count instances of substrings\n        let substringCount = {};\n        for (let substringLength = 2; substringLength < maxSubstringLength; substringLength++)\n            for (let i = 0; i < string.length - substringLength; ++i) {\n                let substring = string.substr(i, substringLength);\n\n                // don't recount if already in list\n                if (substringCount[substring]) continue;\n\n                // prevent breaking up unmatched surrogates\n                if (HasUnmatchedSurrogate(substring)) continue;\n\n                // count how many times the substring appears\n                let count = 1;\n                for (let substringPos = string.indexOf(substring, i + substringLength); substringPos >= 0; ++count)\n                    substringPos = string.indexOf(substring, substringPos + substringLength);\n\n                // add to list if it appears multiple times\n                if (count > 1) substringCount[substring] = count;\n            }\n\n        while (true) {\n            // loop while string can be crushed more\n            // get the next character that is not in the string\n            for (; replaceCharacterPos-- && string.includes(replaceCharacters[replaceCharacterPos]); ) {}\n            if (replaceCharacterPos < 0) break; // ran out of replacement characters\n            let replaceCharacter = replaceCharacters[replaceCharacterPos];\n\n            // find the longest substring to replace\n            let bestSubstring;\n            let bestLengthDelta = 0;\n            let replaceByteLength = ByteLength(replaceCharacter);\n            for (let substring in substringCount) {\n                // calculate change in length of string if it substring was replaced\n                let count = substringCount[substring];\n                let lengthDelta = (count - 1) * ByteLength(substring) - (count + 1) * replaceByteLength;\n                if (!splitString.length) lengthDelta -= ByteLength(delimiter); // include the delimiter length\n                if (lengthDelta <= 0) delete substringCount[substring];\n                else if (lengthDelta > bestLengthDelta) {\n                    bestSubstring = substring;\n                    bestLengthDelta = lengthDelta;\n                }\n            }\n            if (!bestSubstring) break; // string can't be compressed further\n\n            // create new string with the split character\n            string = string.split(bestSubstring).join(replaceCharacter) + replaceCharacter + bestSubstring;\n            splitString = replaceCharacter + splitString;\n\n            // update substring count list after the replacement\n            let newSubstringCount = {};\n            for (let substring in substringCount) {\n                // make a new substring with the replacement\n                let newSubstring = substring.split(bestSubstring).join(replaceCharacter);\n\n                // count how many times the new substring appears\n                let count = 0;\n                for (let i = string.indexOf(newSubstring); i >= 0; ++count)\n                    i = string.indexOf(newSubstring, i + newSubstring.length);\n\n                // add to list if it appears multiple times\n                if (count > 1) newSubstringCount[newSubstring] = count;\n            }\n            substringCount = newSubstringCount;\n        }\n\n        return { a: string, b: splitString };\n    };\n\n    // create a string of replacement characters\n    let characters = [];\n\n    // prefer replacing with characters that will not be escaped by encodeURIComponent\n    const unescapedCharacters = `-_.!~*'()`;\n    for (let i = 127; --i; ) {\n        if (\n            (i >= 48 && i <= 57) || // 0-9\n            (i >= 65 && i <= 90) || // A-Z\n            (i >= 97 && i <= 122) || // a-z\n            unescapedCharacters.includes(String.fromCharCode(i))\n        )\n            characters.push(String.fromCharCode(i));\n    }\n\n    // pick from extended set last\n    for (let i = 32; i < 255; ++i) {\n        let c = String.fromCharCode(i);\n        if (c != '\\\\' && !characters.includes(c)) characters.unshift(c);\n    }\n\n    // remove delimiter if it is found in the string\n    string = string.replace(new RegExp(delimiter, 'g'), '');\n\n    // swap out common json characters\n    string = JSONCrushSwap(string);\n\n    // crush with JS crush\n    const crushed = JSCrush(string, characters);\n\n    // insert delimiter between JSCrush parts\n    let crushedString = crushed.a;\n    if (crushed.b.length) crushedString += delimiter + crushed.b;\n\n    // fix issues with some links not being recognized properly\n    crushedString += '_';\n\n    // encode URI\n    return encodeURIComponent(crushedString);\n};\n\nconst JSONUncrush = (string) => {\n    // string must be a decoded URI component, searchParams.get() does this automatically\n\n    // remove last character\n    string = string.substring(0, string.length - 1);\n\n    // unsplit the string using the delimiter\n    const stringParts = string.split('\\u0001');\n\n    // JSUncrush algorithm\n    let uncrushedString = stringParts[0];\n    if (stringParts.length > 1) {\n        let splitString = stringParts[1];\n        for (let character of splitString) {\n            // split the string using the current splitCharacter\n            let splitArray = uncrushedString.split(character);\n\n            // rejoin the string with the last element from the split\n            uncrushedString = splitArray.join(splitArray.pop());\n        }\n    }\n\n    // unswap the json characters in reverse direction\n    return JSONCrushSwap(uncrushedString, 0);\n};\n\nconst JSONCrushSwap = (string, forward = 1) => {\n    // swap out characters for lesser used ones that wont get escaped\n    const swapGroups = [\n        ['\"', \"'\"],\n        [\"':\", '!'],\n        [\",'\", '~'],\n        ['}', ')', '\\\\', '\\\\'],\n        ['{', '(', '\\\\', '\\\\']\n    ];\n\n    const Swap = (string, g) => {\n        let regex = new RegExp(`${(g[2] ? g[2] : '') + g[0]}|${(g[3] ? g[3] : '') + g[1]}`, 'g');\n        return string.replace(regex, ($1) => ($1 === g[0] ? g[1] : g[0]));\n    };\n\n    // need to be able to swap characters in reverse direction for uncrush\n    if (forward) for (let i = 0; i < swapGroups.length; ++i) string = Swap(string, swapGroups[i]);\n    else for (let i = swapGroups.length; i--; ) string = Swap(string, swapGroups[i]);\n\n    return string;\n};\n\nComlink.expose({\n    crush: JSONCrush,\n    uncrush: JSONUncrush\n});\n"],"names":["$b4abfc73dd03f7e117e3034bdfa3288d$export$proxyMarker","Symbol","$b4abfc73dd03f7e117e3034bdfa3288d$export$createEndpoint","$b4abfc73dd03f7e117e3034bdfa3288d$export$releaseProxy","$b4abfc73dd03f7e117e3034bdfa3288d$var$throwMarker","$b4abfc73dd03f7e117e3034bdfa3288d$var$isObject","val","$b4abfc73dd03f7e117e3034bdfa3288d$export$transferHandlers","Map","$b4abfc73dd03f7e117e3034bdfa3288d$var$proxyTransferHandler","canHandle","serialize","obj","port1","port2","MessageChannel","$b4abfc73dd03f7e117e3034bdfa3288d$export$expose","deserialize","port","start","$b4abfc73dd03f7e117e3034bdfa3288d$var$createProxy","ep","target","$b4abfc73dd03f7e117e3034bdfa3288d$var$throwTransferHandler","value","serialized","Error","isError","message","name","stack","Object","assign","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","$b4abfc73dd03f7e117e3034bdfa3288d$var$fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","$b4abfc73dd03f7e117e3034bdfa3288d$export$proxy","transfers","$b4abfc73dd03f7e117e3034bdfa3288d$var$transferCache","set","$b4abfc73dd03f7e117e3034bdfa3288d$export$transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","$b4abfc73dd03f7e117e3034bdfa3288d$var$toWireValue","postMessage","removeEventListener","$b4abfc73dd03f7e117e3034bdfa3288d$var$closeEndPoint","endpoint","constructor","$b4abfc73dd03f7e117e3034bdfa3288d$var$isMessagePort","close","$b4abfc73dd03f7e117e3034bdfa3288d$var$throwIfProxyReleased","isReleased","isProxyReleased","proxy","Proxy","get","_target","$b4abfc73dd03f7e117e3034bdfa3288d$var$requestResponseMessage","p","toString","length","r","bind","_thisArg","rawArgumentList","last","$b4abfc73dd03f7e117e3034bdfa3288d$var$processArguments","construct","processed","v","arr","Array","prototype","concat","WeakMap","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","$137957d6f81c5ba7722c349a593dc501$var$JSONCrushSwap","string","forward","swapGroups","Swap","g","regex","RegExp","replace","$1","i","crush","maxSubstringLength","characters","unescapedCharacters","includes","String","fromCharCode","push","c","unshift","crushed","replaceCharacters","replaceCharacterPos","splitString","ByteLength","encodeURI","encodeURIComponent","HasUnmatchedSurrogate","c1","charCodeAt","c2","substringCount","substringLength","substring","substr","count","substringPos","indexOf","bestSubstring","replaceCharacter","bestLengthDelta","replaceByteLength","lengthDelta","split","newSubstringCount","newSubstring","a","b","JSCrush","crushedString","uncrush","stringParts","uncrushedString","character","splitArray","pop"],"version":3,"file":"worker.fe49f137.js.map"}